# üß† WEMDAS ‚Äì BZScript Operator Precedence Model

## üìú Definition

**WEMDAS** is BZScript's custom operator precedence model, inspired by PEMDAS, but tailored for a sapient-friendly parse engine.

```
W ‚Äì Wrapping (parentheses or other grouping)
E ‚Äì Evaluation (truth resolution, assignments)
M ‚Äì Multiply / Divide
D ‚Äì Divide (used symbolically, overlaps with M)
A ‚Äì Add / Subtract
S ‚Äì Symbol operations (and/or/not, bitwise, comparisons)
```

## üí° Core Philosophy

- **Grouping comes first.**  
  Wrapping constructs like `(` are explicitly retained as tokens (`node_open`) to encode semantic hints about structure ‚Äî e.g., math group vs function call.

- **Evaluation isn't just assignment.**  
  WEMDAS treats `=` and logical comparisons (==, !=) as part of evaluation logic, often processed **after** wrapping but **before** core arithmetic.

- **Multiply/Divide precedence matches conventional math**, but without conflating logic and arithmetic.

- **Symbol operators (S)** sit at the lowest level ‚Äî things like `and`, `or`, `==`, `<`, `>=`, etc., often requiring left/right node resolution first.

---

## üß™ Example Breakdown

Expression:
```bz
#a = (1 + 2) + (3 * (4 + #b) + #c)
```

### Step-by-step Resolution:
```
1. W: Grouping nodes identified ‚Üí (1 + 2), (4 + #b), (3 * ...), etc.
2. E: = assignment binds #a to the expression
3. M/D: * resolved before surrounding +‚Äôs
4. A: + operations resolved once operands known
5. S: No logical symbols here, but this is where they'd be processed last
```

### Resulting Tree Fragment (Simplified):
```
=
‚îú‚îÄ‚îÄ #a
‚îî‚îÄ‚îÄ +
    ‚îú‚îÄ‚îÄ node (1 + 2)
    ‚îî‚îÄ‚îÄ node (3 * node(4 + #b) + #c)
```

---

## üìò Notes

- **WEMDAS is enforced in `op_group` + `op_*` family.**
- Designed for **predictability**, **pattern-based parsing**, and **reduction-friendly recursion**.
- May evolve as new token types (e.g., array access, function call, ternary) are introduced.

---

## üõ†Ô∏è Status

‚úÖ Implemented  
üß™ Tested on deeply nested expressions  
üîí Safety checks pending  
üì¶ Formal grammar in progress (see `language.e`)

## üåÄ Grouping Without a Stack ‚Äì A Unique BZScript Innovation

Most languages and parsers resolve parentheses, brackets, and other group structures using a **stack-based** model:

- Push on open
- Pop on close
- Hope everything matches up

BZScript takes a different route ‚Äî one that's more **data-oriented**, **tree-conscious**, and **debuggable**.

---

### ‚ùå The Traditional Way: Stack-Based Nesting

While efficient, stack-based grouping is:
- Rigid
- Implicit
- Often hard to introspect or repair mid-flight

It doesn't expose much metadata, and error recovery can be painful once the stack's been poisoned.

---

### ‚úÖ The BZ Way: Token-Driven Tree Construction

Instead of pushing/popping tokens, BZScript builds **explicit `group_open` nodes** directly into the AST stream. Each opening token (`(`, `[`, etc.) becomes a **node token** with children. As the stream is walked:

- Tokens are **attached as children** to their owning group
- Closing tokens are **discarded once group resolution completes**
- Groups self-reduce to **semantic nodes** (math, array, function, etc.)

This means the parse tree is always:
- **Transparent** ‚Äî every group is a node, even mid-resolution
- **Recoverable** ‚Äî you can inspect and modify it on the fly
- **Extensible** ‚Äî other group types (e.g. delimiters, list unpacking) can fit into the same model

---

### üß¨ Why It Matters

This model unlocks things that traditional stacks struggle with:
- Hybrid parsing/evaluation (e.g., reduce while you walk)
- Visual debugging (groupings show up as tree branches)
- AST patching and delayed resolution
- Meaningful error reporting tied to actual token nodes

This isn‚Äôt just about nesting. It‚Äôs about **making the invisible structure visible** ‚Äî and giving it a role in the reduction flow.

---

### üîç In Code

See:
- `op_group` in `ast.e`
- Token metadata like `kind: node_open` from `tokenizer.e`
- Child resolution helpers (`child_on_left`, `child_on_both_sides`, etc.)

---

### üõ†Ô∏è Status

- ‚úÖ Stable for `()`
- üîú Future: `[]`, `{}`, function calls, list literals
- üß™ Extensible into other syntax forms (e.g., ternary, pipe, filter expressions)


---

## üîç Comparison: Traditional Stack vs BZ Group Nodes

### üß† Stack-Based Grouping (Traditional)

```
Input:
  #a = (1 + (2 * 3))

Stack Walk:
  [      ‚Üê push (
  +      ‚Üê nothing (accumulate)
  [      ‚Üê push (
  *      ‚Üê nothing
  ]      ‚Üê pop (resolve 2 * 3)
  ]      ‚Üê pop (resolve 1 + result)

Final Tree (built at pop-time):
  =
  ‚îú‚îÄ‚îÄ #a
  ‚îî‚îÄ‚îÄ +
      ‚îú‚îÄ‚îÄ 1
      ‚îî‚îÄ‚îÄ *
          ‚îú‚îÄ‚îÄ 2
          ‚îî‚îÄ‚îÄ 3
```

**Pros:** fast, memory-efficient  
**Cons:** opaque mid-way, poor error recovery, limited metadata

---

### üß† BZScript Group-Node Parsing (No Stack)

```
Input:
  #a = (1 + (2 * 3))

AST Walk:
  group_open(
    add
      ‚îú‚îÄ‚îÄ literal 1
      ‚îî‚îÄ‚îÄ group_open(
            multiply
              ‚îú‚îÄ‚îÄ literal 2
              ‚îî‚îÄ‚îÄ literal 3
          )
  )

Final Tree (always visible mid-walk):
  =
  ‚îú‚îÄ‚îÄ #a
  ‚îî‚îÄ‚îÄ group_open
      ‚îî‚îÄ‚îÄ +
          ‚îú‚îÄ‚îÄ 1
          ‚îî‚îÄ‚îÄ group_open
              ‚îî‚îÄ‚îÄ *
                  ‚îú‚îÄ‚îÄ 2
                  ‚îî‚îÄ‚îÄ 3
```

**Pros:**
- Every open group is a node ‚Äî not just syntax, but data
- Groups can carry metadata (e.g., math, function, array)
- Mid-walk introspection is easy
- Easy to add behavior like `group.reduce()` or `group.patch()`

**Cons:** Slightly more memory per group (token nodes are heavier than stack markers)

---

üìå **In BZScript, grouping is not just structural ‚Äî it‚Äôs semantic.**
The parentheses aren‚Äôt just markers, they‚Äôre **typed containers** in the tree, ready for introspection, transformation, or reduction.

---

## üß† Deep Nesting: Stack vs BZScript Comparison

### Input
```text
#a = ((((#x + 1) * 2) - ((3 / (#y + 4)) + 5)))
```

---

### üì¶ Traditional Stack Parser

**Approach:** Push/pop with reduction at close

```
=
‚îú‚îÄ‚îÄ #a
‚îî‚îÄ‚îÄ -
    ‚îú‚îÄ‚îÄ *
    ‚îÇ   ‚îú‚îÄ‚îÄ +
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ #x
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 1
    ‚îÇ   ‚îî‚îÄ‚îÄ 2
    ‚îî‚îÄ‚îÄ +
        ‚îú‚îÄ‚îÄ /
        ‚îÇ   ‚îú‚îÄ‚îÄ 3
        ‚îÇ   ‚îî‚îÄ‚îÄ +
        ‚îÇ       ‚îú‚îÄ‚îÄ #y
        ‚îÇ       ‚îî‚îÄ‚îÄ 4
        ‚îî‚îÄ‚îÄ 5
```

**Note:** This tree is only visible after the final closing paren. Mid-walk state is opaque and error-prone.

---

### üåø BZScript Group-Node Parser (No Stack)

**Approach:** Groupings are typed `node_open` tokens with children

```
=
‚îú‚îÄ‚îÄ #n
‚îî‚îÄ‚îÄ node_open
    ‚îî‚îÄ‚îÄ node_open
        ‚îî‚îÄ‚îÄ -
            ‚îú‚îÄ‚îÄ node_open
            ‚îÇ   ‚îî‚îÄ‚îÄ *
            ‚îÇ       ‚îú‚îÄ‚îÄ node_open
            ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ +
            ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ #x
            ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ 1
            ‚îÇ       ‚îî‚îÄ‚îÄ 2
            ‚îî‚îÄ‚îÄ node_open
                ‚îî‚îÄ‚îÄ +
                    ‚îú‚îÄ‚îÄ node_open
                    ‚îÇ   ‚îî‚îÄ‚îÄ /
                    ‚îÇ       ‚îú‚îÄ‚îÄ 3
                    ‚îÇ       ‚îî‚îÄ‚îÄ node_open
                    ‚îÇ           ‚îî‚îÄ‚îÄ +
                    ‚îÇ               ‚îú‚îÄ‚îÄ #y
                    ‚îÇ               ‚îî‚îÄ‚îÄ 4
                    ‚îî‚îÄ‚îÄ 5
```

**Highlights:**
- Each `node_open` corresponds to a parenthesis group
- Walkable at all stages of parsing
- Self-contained groups with reduction metadata
- Behavior can differ based on group type (`math`, `function`, `array`...)

---

### üîß Implementation Insight

> Grouping in BZScript isn‚Äôt syntactic sugar ‚Äî it‚Äôs **structure with behavior**.  
Each group node knows *why it exists*, what kind it is, and how to reduce itself.  
No stack needed. No invisible state. Just token trees ‚Äî all the way down.

# üß© Addendum: Flattening WEMDAS Group Nodes

## Background

The current AST generated by the WEMDAS engine includes explicit `node_open` tokens for each group in the original expression. These tokens preserve metadata about the original structure, making it possible to:

* Distinguish between group types (e.g., math group vs. array vs. function)
* Control operator precedence through nested structures
* Maintain a traceable structure for debugging, analysis, or educational tools

However, some downstream consumers (e.g., visualizers, optimizers, or interpreters) may prefer a flattened tree where those intermediate nodes are removed once no longer necessary.

---

## ‚úÇÔ∏è Flattening Strategy

The goal of flattening is to:

* **Eliminate `node_open` tokens** that merely wrap a single child or a reducible subexpression
* **Promote their child nodes** into the parent AST level

This is purely optional and can be performed as a **post-pass transformation** on the AST.

### Pseudocode Example

```euphoria
function collapse_group_nodes(TAstToken token)
    if token.kind = NODE_OPEN then
        if length(token.children) = 1 then
            return collapse_group_nodes(token.children[1])
        else
            for i = 1 to length(token.children) do
                token.children[i] = collapse_group_nodes(token.children[i])
            end for
        return token
    elsif token.children != {} then
        for i = 1 to length(token.children) do
            token.children[i] = collapse_group_nodes(token.children[i])
        end for
    end if
    return token
end function
```

---

## üß† Why Keep the Original Nodes?

You may want to **retain `node_open` tokens** if:

* You want **full fidelity** to the source expression for rendering or export
* You‚Äôre performing **symbolic manipulation**, where group type matters
* You need **explicit boundaries** for precedence during later transforms

Flattening is best reserved for final stages of compilation or interpretation, not during parsing.

---

## ‚úÖ Summary

* WEMDAS is designed to preserve structural intent via `node_open`
* Flattening is optional, safe, and context-sensitive
* A well-isolated post-pass transformer gives you the best of both:

  * Full precision during parsing
  * Simplified form when needed

> "Structure first. Meaning second. Code last." ‚Äì WEMDAS Philosophy




